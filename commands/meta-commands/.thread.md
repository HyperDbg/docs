---
description: Description of '.thread' and '.thread2' commands in HyperDbg.
---

# .thread, .thread2 (show the current thread and switch to another thread)

### Command

> .thread
>
> .thread2

### Syntax

> .thread \[type (tid | thread | list)] \[new thread id (hex) | new nt!\_ETHREAD address | list (process)] \[process's nt!\_EPROCESS]
>
> .thread2 \[type (tid | thread | list)] \[new thread id (hex) | new nt!\_ETHREAD address | list (process)] \[process's nt!\_EPROCESS]

### Description

Shows or changes the current thread. These commands can only be used in **Debugger Mode**.

{% hint style="danger" %}
**Important:** the implementation of these commands is different. Please visit [**this article**](https://docs.hyperdbg.org/tips-and-tricks/considerations/difference-between-process-and-thread-switching-commands) to be aware of the differences and to know when you should use the '**.thread**' command and when you should use the alternative '.**thread2**' command.
{% endhint %}

If you want to change the thread to a new thread, after using the '**.thread**' or the '**.thread2**' commands, you should use the '[g](https://docs.hyperdbg.org/commands/debugging-commands/g)' command.

### Parameters

**\[type (tid | thread | list)] (optional)**

It shows that you want to specify a thread id or an `_ETHREAD` at the second parameter or if the user wants to see the list of threads.

**\[new thread id (hex) | new nt!\_ETHREAD address | list (process)] (optional)**

The thread id or `_ETHREAD` of the thread that you want to switch to it.

**\[process's nt!\_EPROCESS] (optional)**

If you specified `list process` as the arguments to this command, you should enter the `_EPROCESS` of the process that you want to see its threads.

{% hint style="success" %}
If you don't specify any parameters to the '**.thread**' or the '**.thread2**' commands, it shows the current process.
{% endhint %}

### Examples

```
3: kHyperDbg> .thread
thread id: e80 (pid: 40c)
thread (_ETHREAD): ffff948c`ba35a080
process (_EPROCESS): ffff948c`c1594340
process name (16-Byte): hyperdbg-cli.e
```

```
2: kHyperDbg> .thread tid 23f8
press 'g' to continue the debuggee, if the tid is valid then the debuggee will be automatically paused when it attached to the target thread

2: kHyperDbg> g
debuggee is running...
switched to the specified thread
fffff801`63265c52    0F B6 87 84 01 00 00                movzx eax, byte ptr ds:[rdi+0x184]

3: kHyperDbg> .thread
thread id: 23f8 (pid: 1b6c)
thread (_ETHREAD): ffff948c`c1957080
process (_EPROCESS): ffff948c`c0a0d080
process name (16-Byte): test.exe
```

```
2: kHyperDbg> .thread thread ffff948c`c1957080
press 'g' to continue the debuggee, if the tid is valid then the debuggee will be automatically paused when it attached to the target thread

2: kHyperDbg> g
debuggee is running...
switched to the specified thread
00007ff6`e8df2450    90                                  nop
```

```
2: kHyperDbg> .thread list
PROCESS ffff948cc1594340        IMAGE   hyperdbg-cli.e
        THREAD  ffff948cba186080 (40c.20c8)
        THREAD  ffff948cbfc7b080 (40c.1794)
        THREAD  ffff948cba35a080 (40c.e80)
```

```
2: kHyperDbg> .thread list process ffff948cc1590340
PROCESS ffff948cc1590340        IMAGE   MicrosoftEdgeU
        THREAD  ffff948cbf8f2080 (e08.1918)
        THREAD  ffff948cc056c080 (e08.c88)
        THREAD  ffff948cbfedf040 (e08.628)
        THREAD  ffff948cbf3ad080 (e08.18c0)
        THREAD  ffff948cc09ed080 (e08.1b00)
        THREAD  ffff948cc14ea080 (e08.888)
```

### IOCTL

This commands works over serial by sending the serial packets to the remote computer.

First of all, you should fill the following structure, set the `ProcessId` or `Process` to your target process (if you want to change the current process), set the `ActionType` to `DEBUGGEE_DETAILS_AND_SWITCH_PROCESS_PERFORM_SWITCH` and leave the `Result`.

This is the enum for action type.

```
typedef enum _DEBUGGEE_DETAILS_AND_SWITCH_PROCESS_TYPE
{

    DEBUGGEE_DETAILS_AND_SWITCH_PROCESS_PERFORM_SWITCH,
    DEBUGGEE_DETAILS_AND_SWITCH_PROCESS_GET_PROCESS_DETAILS,
    DEBUGGEE_DETAILS_AND_SWITCH_PROCESS_GET_PROCESS_LIST,

} DEBUGGEE_DETAILS_AND_SWITCH_PROCESS_TYPE;
```

If you want to get the current process id and `_EPROCESS`, then set the `ActionType` to `DEBUGGEE_DETAILS_AND_SWITCH_PROCESS_GET_PROCESS_DETAILS` and leave the `ProcessId` and `Process`.

If you want to see the list of processes, you should set the `ActionType` to `DEBUGGEE_DETAILS_AND_SWITCH_PROCESS_GET_PROCESS_LIST`.

When you set `IsSwitchByClkIntr` to `TRUE`, the semantics for the '**.process**' is used and if you set it to `FALSE` then the '**.process2**''s semantic is used for the **process switch** request.

```c
typedef struct _DEBUGGEE_DETAILS_AND_SWITCH_PROCESS_PACKET
{
    DEBUGGEE_DETAILS_AND_SWITCH_PROCESS_TYPE ActionType;
    UINT32                                   ProcessId;
    UINT64                                   Process;
    BOOLEAN                                  IsSwitchByClkIntr;
    UCHAR                                    ProcessName[16];
    DEBUGGEE_PROCESS_LIST_NEEDED_DETAILS     ProcessListSymDetails;
    UINT32                                   Result;

} DEBUGGEE_DETAILS_AND_SWITCH_PROCESS_PACKET, *PDEBUGGEE_DETAILS_AND_SWITCH_PROCESS_PACKET;

```

After that, send the above structure to the debuggee when debuggee is paused and waiting for new command on **vmx-root** mode.

You should send the above structure with `DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_MODE_CHANGE_PROCESS` as `RequestedAction` and `DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGER_TO_DEBUGGEE_EXECUTE_ON_VMX_ROOT` as `PacketType`.

In return, the debuggee sends the above structure with the following type.

```c
DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_RESULT_OF_CHANGING_PROCESS
```

In the returned structure, the `Result` is filled by the kernel.

If the `Result` is `DEBUGEER_OPERATION_WAS_SUCCESSFULL`, then the operation was successful, and you should use the '[g](https://docs.hyperdbg.org/commands/debugging-commands/g)' command to move to the new process. Otherwise, the returned result is an error, and the current process is not changed. If you want the current process, then if the `Result` is `DEBUGEER_OPERATION_WAS_SUCCESSFULL`, then the current process id is stored at `ProcessId`.

The following function is responsible for changing the core in the debugger.

```c
BOOLEAN
KdSendSwitchProcessPacketToDebuggee(DEBUGGEE_DETAILS_AND_SWITCH_PROCESS_TYPE ActionType,
                                    UINT32                                   NewPid,
                                    UINT64                                   NewProcess,
                                    BOOLEAN                                  SetChangeByClockInterrupt,
                                    PDEBUGGEE_PROCESS_LIST_NEEDED_DETAILS    SymDetailsForProcessList);
```

### Remarks

If you want to see a list of processes, you need to load the public symbol file (PDB) for the ntoskrnl.exe using the '[.sym](https://docs.hyperdbg.org/commands/meta-commands/.sym)' command.

The difference between these commands is explained [here](https://docs.hyperdbg.org/tips-and-tricks/considerations/difference-between-process-and-thread-switching-commands).

If you've entered an invalid address as `_EPROCESS` or an invalid process id, HyperDbg keeps checking for the target address or PID, and whenever the debugger is paused again, it won't check for the process anymore.

It also means that if you press the '[g](https://docs.hyperdbg.org/commands/debugging-commands/g)' command and an event or a breakpoint is triggered before switching to the new process, switching will be ignored, and you need to re-switch to the target process and use the '**.process**' or '**.process2**' commands again.

Some processes might never trigger even if their process id or `EPROCESS` is valid. It is because in these cases, Windows halts or suspends those processes and never switches to them. In these cases, you can switch to the memory layout of the target process by changing **cr3** to your target **cr3**. For more details, please visit [here](https://docs.hyperdbg.org/tips-and-tricks/misc/switch-to-new-process-layout).

HyperDbg guarantees that the target process won't get the chance to be executed while the switch is performed. However, make sure that your target process is not currently processing on any cores in the processor.

### Requirements

None

### Related

None
